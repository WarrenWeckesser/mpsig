
import sys
import os
import subprocess

import mpsig


# The function git_version() returns the git revision as a string.
# This function is from scipy's setup.py.  It has the following license:
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - - -
# Copyright (c) 2001-2002 Enthought, Inc.  2003-2019, SciPy Developers.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above
#    copyright notice, this list of conditions and the following
#    disclaimer in the documentation and/or other materials provided
#    with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - - - - - -
def git_version():
    def _minimal_ext_cmd(cmd):
        # construct minimal environment
        env = {}
        for k in ['SYSTEMROOT', 'PATH']:
            v = os.environ.get(k)
            if v is not None:
                env[k] = v
        # LANGUAGE is used on win32
        env['LANGUAGE'] = 'C'
        env['LANG'] = 'C'
        env['LC_ALL'] = 'C'
        out = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                               env=env).communicate()[0]
        return out

    try:
        out = _minimal_ext_cmd(['git', 'rev-parse', 'HEAD'])
        git_revision = out.strip().decode('ascii')
    except OSError:
        git_revision = None

    return git_revision


try:
    os.mkdir('source')
except FileExistsError:
    print("'source' exists.  Either remove or move it.")
    print("No files created.")
    sys.exit(0)


gitrev = git_version()
if gitrev:
    gitrev = gitrev[:8] + "..."
else:
    gitrev = "unknown"

main_descr = f"""
(*Git revision:* ``{gitrev}``)

``mpsig`` is a package that implements a few functions related to
signal processing, using the arbitrary precision library ``mpmath``
for its calculations.
"""

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Create README.txt

readme_filename = os.path.join('source', 'README.txt')

with open(readme_filename, 'w') as f:
    f.write(f'''
DO NOT EDIT ANYTHING IN THIS DIRECTORY!

All the files in this directory (including this one) were generated by
the script '{__file__}'.
''')

preamble_lines = [
    '..',
    '   DO NOT EDIT THIS FILE!',
    '   ',
    "   This file was generated by the script '%s'." % __file__,
    '',
    '',
]

preamble = '\n'.join(preamble_lines)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Create index.rst

lines = []
lines.extend(preamble_lines)
lines.extend(['mpsig', '=====', ''])
lines.extend([main_descr, ''])

names = [name for name in dir(mpsig) if not name.startswith('_')]
lines.extend(['.. _mpsig:', ''])
lines.extend(['.. currentmodule:: mpsig', ''])
lines.extend(['.. automodule:: mpsig', ''])
lines.extend(['.. autosummary::', ''])
for name in names:
    lines.extend(['   ' + name])

content = '\n'.join(lines)
index_name = os.path.join('source', 'index.rst')
with open(index_name, 'w') as f:
    f.write(content)
